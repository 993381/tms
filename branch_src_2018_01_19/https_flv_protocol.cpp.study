#include <iostream>
#include <map>

#include "base_64.h"
#include "bit_buffer.h"
#include "bit_stream.h"
#include "common_define.h"
#include "global.h"
#include "https_flv_mgr.h"
#include "https_flv_protocol.h"
#include "io_buffer.h"
#include "local_stream_center.h"
#include "media_center_mgr.h"
#include "ref_ptr.h"
#include "rtmp_protocol.h"
#include "server_protocol.h"
#include "rtmp_mgr.h"
#include "server_mgr.h"
#include "tcp_socket.h"

#include <openssl/rsa.h>

using namespace std;

enum ContentType
{
    kChangeCipherSpec = 20,
    kAlert = 21,
    kHandshake = 22,
    kApplicationData = 23,
};

enum HandshakeType
{
    kHelloRequest = 0, 
    kClientHello = 1, 
    kServerHello = 2, 
    kCertificate = 11, 
    kServerKeyExchange  = 12, 
    kCertificateRequest = 13, 
    kServerHelloDone = 14, 
    kCertificateVerify = 15, 
    kClientKeyExchange = 16, 
    kFinished = 20, 
};

map<uint16_t, string> kCiphersTable = 
{
	{0x0000, "SSL_NULL_WITH_NULL_NULL"},
    {0x0001, "SSL_RSA_WITH_NULL_MD5"},
    {0x0002, "SSL_RSA_WITH_NULL_SHA"},
    {0x0003, "SSL_RSA_EXPORT_WITH_RC4_40_MD5"},
    {0x0004, "SSL_RSA_WITH_RC4_128_MD5"},
    {0x0005, "SSL_RSA_WITH_RC4_128_SHA"},
    {0x0006, "SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5"},
    {0x0007, "SSL_RSA_WITH_IDEA_CBC_SHA"},
    {0x0008, "SSL_RSA_EXPORT_WITH_DES40_CBC_SHA"},
    {0x0009, "SSL_RSA_WITH_DES_CBC_SHA"},
    {0x000A, "SSL_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0x000B, "SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"},
    {0x000C, "SSL_DH_DSS_WITH_DES_CBC_SHA"},
    {0x000D, "SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA"},
    {0x000E, "SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"},
    {0x000F, "SSL_DH_RSA_WITH_DES_CBC_SHA"},
    {0x0010, "SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0x0011, "SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"},
    {0x0012, "SSL_DHE_DSS_WITH_DES_CBC_SHA"},
    {0x0013, "SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA"},
    {0x0014, "SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"},
    {0x0015, "SSL_DHE_RSA_WITH_DES_CBC_SHA"},
    {0x0016, "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0x0017, "SSL_DH_anon_EXPORT_WITH_RC4_40_MD5"},
    {0x0018, "SSL_DH_anon_WITH_RC4_128_MD5"},
    {0x0019, "SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA"},
    {0x001A, "SSL_DH_anon_WITH_DES_CBC_SHA"},
    {0x001B, "SSL_DH_anon_WITH_3DES_EDE_CBC_SHA"},
    {0x001D, "SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"},
    {0x001E, "SSL_FORTEZZA_KEA_WITH_RC4_128_SHA"},
    {0x001F, "TLS_KRB5_WITH_3DES_EDE_CBC_SHA"},
    {0x0020, "TLS_KRB5_WITH_RC4_128_SHA"},
    {0x0021, "TLS_KRB5_WITH_IDEA_CBC_SHA"},
    {0x0022, "TLS_KRB5_WITH_DES_CBC_MD5"},
    {0x0023, "TLS_KRB5_WITH_3DES_EDE_CBC_MD5"},
    {0x0024, "TLS_KRB5_WITH_RC4_128_MD5"},
    {0x0025, "TLS_KRB5_WITH_IDEA_CBC_MD5"},
    {0x0026, "TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"},
    {0x0027, "TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"},
    {0x0028, "TLS_KRB5_EXPORT_WITH_RC4_40_SHA"},
    {0x0029, "TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"},
    {0x002A, "TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"},
    {0x002B, "TLS_KRB5_EXPORT_WITH_RC4_40_MD5"},
    {0x002C, "TLS_PSK_WITH_NULL_SHA"},
    {0x002D, "TLS_DHE_PSK_WITH_NULL_SHA"},
    {0x002E, "TLS_RSA_PSK_WITH_NULL_SHA"},
    {0x002F, "TLS_RSA_WITH_AES_128_CBC_SHA"},
    {0x0030, "TLS_DH_DSS_WITH_AES_128_CBC_SHA"},
    {0x0031, "TLS_DH_RSA_WITH_AES_128_CBC_SHA"},
    {0x0032, "TLS_DHE_DSS_WITH_AES_128_CBC_SHA"},
    {0x0033, "TLS_DHE_RSA_WITH_AES_128_CBC_SHA"},
    {0x0034, "TLS_DH_anon_WITH_AES_128_CBC_SHA"},
    {0x0035, "TLS_RSA_WITH_AES_256_CBC_SHA"},
    {0x0036, "TLS_DH_DSS_WITH_AES_256_CBC_SHA"},
    {0x0037, "TLS_DH_RSA_WITH_AES_256_CBC_SHA"},
    {0x0038, "TLS_DHE_DSS_WITH_AES_256_CBC_SHA"},
    {0x0039, "TLS_DHE_RSA_WITH_AES_256_CBC_SHA"},
    {0x003A, "TLS_DH_anon_WITH_AES_256_CBC_SHA"},
    {0x003B, "TLS_RSA_WITH_NULL_SHA256"},
    {0x003C, "TLS_RSA_WITH_AES_128_CBC_SHA256"},
    {0x003D, "TLS_RSA_WITH_AES_256_CBC_SHA256"},
    {0x003E, "TLS_DH_DSS_WITH_AES_128_CBC_SHA256"},
    {0x003F, "TLS_DH_RSA_WITH_AES_128_CBC_SHA256"},
    {0x0040, "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"},
    {0x0041, "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0042, "TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0043, "TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0044, "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0045, "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0046, "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"},
    {0x0067, "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"},
    {0x0068, "TLS_DH_DSS_WITH_AES_256_CBC_SHA256"},
    {0x0069, "TLS_DH_RSA_WITH_AES_256_CBC_SHA256"},
    {0x006A, "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"},
    {0x006B, "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"},
    {0x006C, "TLS_DH_anon_WITH_AES_128_CBC_SHA256"},
    {0x006D, "TLS_DH_anon_WITH_AES_256_CBC_SHA256"},
    {0x0084, "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"},
    {0x0085, "TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"},
    {0x0086, "TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"},
    {0x0087, "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"},
    {0x0088, "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"},
    {0x0089, "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"},
    {0x008A, "TLS_PSK_WITH_RC4_128_SHA"},
    {0x008B, "TLS_PSK_WITH_3DES_EDE_CBC_SHA"},
    {0x008C, "TLS_PSK_WITH_AES_128_CBC_SHA"},
    {0x008D, "TLS_PSK_WITH_AES_256_CBC_SHA"},
    {0x008E, "TLS_DHE_PSK_WITH_RC4_128_SHA"},
    {0x008F, "TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"},
    {0x0090, "TLS_DHE_PSK_WITH_AES_128_CBC_SHA"},
    {0x0091, "TLS_DHE_PSK_WITH_AES_256_CBC_SHA"},
    {0x0092, "TLS_RSA_PSK_WITH_RC4_128_SHA"},
    {0x0093, "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"},
    {0x0094, "TLS_RSA_PSK_WITH_AES_128_CBC_SHA"},
    {0x0095, "TLS_RSA_PSK_WITH_AES_256_CBC_SHA"},
    {0x0096, "TLS_RSA_WITH_SEED_CBC_SHA"},
    {0x0097, "TLS_DH_DSS_WITH_SEED_CBC_SHA"},
    {0x0098, "TLS_DH_RSA_WITH_SEED_CBC_SHA"},
    {0x0099, "TLS_DHE_DSS_WITH_SEED_CBC_SHA"},
    {0x009A, "TLS_DHE_RSA_WITH_SEED_CBC_SHA"},
    {0x009B, "TLS_DH_anon_WITH_SEED_CBC_SHA"},
    {0x009C, "TLS_RSA_WITH_AES_128_GCM_SHA256"},
    {0x009D, "TLS_RSA_WITH_AES_256_GCM_SHA384"},
    {0x009E, "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"},
    {0x009F, "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"},
    {0x00A0, "TLS_DH_RSA_WITH_AES_128_GCM_SHA256"},
    {0x00A1, "TLS_DH_RSA_WITH_AES_256_GCM_SHA384"},
    {0x00A2, "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"},
    {0x00A3, "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"},
    {0x00A4, "TLS_DH_DSS_WITH_AES_128_GCM_SHA256"},
    {0x00A5, "TLS_DH_DSS_WITH_AES_256_GCM_SHA384"},
    {0x00A6, "TLS_DH_anon_WITH_AES_128_GCM_SHA256"},
    {0x00A7, "TLS_DH_anon_WITH_AES_256_GCM_SHA384"},
    {0x00A8, "TLS_PSK_WITH_AES_128_GCM_SHA256"},
    {0x00A9, "TLS_PSK_WITH_AES_256_GCM_SHA384"},
    {0x00AA, "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"},
    {0x00AB, "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"},
    {0x00AC, "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"},
    {0x00AD, "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"},
    {0x00AE, "TLS_PSK_WITH_AES_128_CBC_SHA256"},
    {0x00AF, "TLS_PSK_WITH_AES_256_CBC_SHA384"},
    {0x00B0, "TLS_PSK_WITH_NULL_SHA256"},
    {0x00B1, "TLS_PSK_WITH_NULL_SHA384"},
    {0x00B2, "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"},
    {0x00B3, "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"},
    {0x00B4, "TLS_DHE_PSK_WITH_NULL_SHA256"},
    {0x00B5, "TLS_DHE_PSK_WITH_NULL_SHA384"},
    {0x00B6, "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"},
    {0x00B7, "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"},
    {0x00B8, "TLS_RSA_PSK_WITH_NULL_SHA256"},
    {0x00B9, "TLS_RSA_PSK_WITH_NULL_SHA384"},
    {0x00BA, "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00BB, "TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00BC, "TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00BD, "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00BE, "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00BF, "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"},
    {0x00C0, "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00C1, "TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00C2, "TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00C3, "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00C4, "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00C5, "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"},
    {0x00FF, "TLS_EMPTY_RENEGOTIATION_INFO_SCSV"},
    {0x5600, "TLS_FALLBACK_SCSV"},
    {0xC001, "TLS_ECDH_ECDSA_WITH_NULL_SHA"},
    {0xC002, "TLS_ECDH_ECDSA_WITH_RC4_128_SHA"},
    {0xC003, "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"},
    {0xC004, "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"},
    {0xC005, "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"},
    {0xC006, "TLS_ECDHE_ECDSA_WITH_NULL_SHA"},
    {0xC007, "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"},
    {0xC008, "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"},
    {0xC009, "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"},
    {0xC00A, "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"},
    {0xC00B, "TLS_ECDH_RSA_WITH_NULL_SHA"},
    {0xC00C, "TLS_ECDH_RSA_WITH_RC4_128_SHA"},
    {0xC00D, "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0xC00E, "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"},
    {0xC00F, "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"},
    {0xC010, "TLS_ECDHE_RSA_WITH_NULL_SHA"},
    {0xC011, "TLS_ECDHE_RSA_WITH_RC4_128_SHA"},
    {0xC012, "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0xC013, "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"},
    {0xC014, "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"},
    {0xC015, "TLS_ECDH_anon_WITH_NULL_SHA"},
    {0xC016, "TLS_ECDH_anon_WITH_RC4_128_SHA"},
    {0xC017, "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"},
    {0xC018, "TLS_ECDH_anon_WITH_AES_128_CBC_SHA"},
    {0xC019, "TLS_ECDH_anon_WITH_AES_256_CBC_SHA"},
    {0xC01A, "TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"},
    {0xC01B, "TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"},
    {0xC01C, "TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"},
    {0xC01D, "TLS_SRP_SHA_WITH_AES_128_CBC_SHA"},
    {0xC01E, "TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"},
    {0xC01F, "TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"},
    {0xC020, "TLS_SRP_SHA_WITH_AES_256_CBC_SHA"},
    {0xC021, "TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"},
    {0xC022, "TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"},
    {0xC023, "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"},
    {0xC024, "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"},
    {0xC025, "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"},
    {0xC026, "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"},
    {0xC027, "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"},
    {0xC028, "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"},
    {0xC029, "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"},
    {0xC02A, "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"},
    {0xC02B, "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"},
    {0xC02C, "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"},
    {0xC02D, "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"},
    {0xC02E, "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"},
    {0xC02F, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"},
    {0xC030, "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"},
    {0xC031, "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"},
    {0xC032, "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"},
    {0xC033, "TLS_ECDHE_PSK_WITH_RC4_128_SHA"},
    {0xC034, "TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"},
    {0xC035, "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"},
    {0xC036, "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"},
    {0xC037, "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"},
    {0xC038, "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"},
    {0xC039, "TLS_ECDHE_PSK_WITH_NULL_SHA"},
    {0xC03A, "TLS_ECDHE_PSK_WITH_NULL_SHA256"},
    {0xC03B, "TLS_ECDHE_PSK_WITH_NULL_SHA384"},
    {0xC03C, "TLS_RSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC03D, "TLS_RSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC03E, "TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"},
    {0xC03F, "TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"},
    {0xC040, "TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC041, "TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC042, "TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"},
    {0xC043, "TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"},
    {0xC044, "TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC045, "TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC046, "TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"},
    {0xC047, "TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"},
    {0xC048, "TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC049, "TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC04A, "TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC04B, "TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC04C, "TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC04D, "TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC04E, "TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"},
    {0xC04F, "TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"},
    {0xC050, "TLS_RSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC051, "TLS_RSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC052, "TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC053, "TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC054, "TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC055, "TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC056, "TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256"},
    {0xC057, "TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384"},
    {0xC058, "TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"},
    {0xC059, "TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"},
    {0xC05A, "TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"},
    {0xC05B, "TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"},
    {0xC05C, "TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC05D, "TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC05E, "TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC05F, "TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC060, "TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC061, "TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC062, "TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"},
    {0xC063, "TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"},
    {0xC064, "TLS_PSK_WITH_ARIA_128_CBC_SHA256"},
    {0xC065, "TLS_PSK_WITH_ARIA_256_CBC_SHA384"},
    {0xC066, "TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"},
    {0xC067, "TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"},
    {0xC068, "TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"},
    {0xC069, "TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"},
    {0xC06A, "TLS_PSK_WITH_ARIA_128_GCM_SHA256"},
    {0xC06B, "TLS_PSK_WITH_ARIA_256_GCM_SHA384"},
    {0xC06C, "TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256"},
    {0xC06D, "TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384"},
    {0xC06E, "TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"},
    {0xC06F, "TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"},
    {0xC070, "TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"},
    {0xC071, "TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"},
    {0xC072, "TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC073, "TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC074, "TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC075, "TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC076, "TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC077, "TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC078, "TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC079, "TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC07A, "TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC07B, "TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC07C, "TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC07D, "TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC07E, "TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC07F, "TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC080, "TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC081, "TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC082, "TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC083, "TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC084, "TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC085, "TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC086, "TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC087, "TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC088, "TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC089, "TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC08A, "TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC08B, "TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC08C, "TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC08D, "TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC08E, "TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC08F, "TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC090, "TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC091, "TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC092, "TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"},
    {0xC093, "TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"},
    {0xC094, "TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC095, "TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC096, "TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC097, "TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC098, "TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC099, "TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC09A, "TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"},
    {0xC09B, "TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"},
    {0xC09C, "TLS_RSA_WITH_AES_128_CCM"},
    {0xC09D, "TLS_RSA_WITH_AES_256_CCM"},
    {0xC09E, "TLS_DHE_RSA_WITH_AES_128_CCM"},
    {0xC09F, "TLS_DHE_RSA_WITH_AES_256_CCM"},
    {0xC0A0, "TLS_RSA_WITH_AES_128_CCM_8"},
    {0xC0A1, "TLS_RSA_WITH_AES_256_CCM_8"},
    {0xC0A2, "TLS_DHE_RSA_WITH_AES_128_CCM_8"},
    {0xC0A3, "TLS_DHE_RSA_WITH_AES_256_CCM_8"},
    {0xC0A4, "TLS_PSK_WITH_AES_128_CCM"},
    {0xC0A5, "TLS_PSK_WITH_AES_256_CCM"},
    {0xC0A6, "TLS_DHE_PSK_WITH_AES_128_CCM"},
    {0xC0A7, "TLS_DHE_PSK_WITH_AES_256_CCM"},
    {0xC0A8, "TLS_PSK_WITH_AES_128_CCM_8"},
    {0xC0A9, "TLS_PSK_WITH_AES_256_CCM_8"},
    {0xC0AA, "TLS_PSK_DHE_WITH_AES_128_CCM_8"},
    {0xC0AB, "TLS_PSK_DHE_WITH_AES_256_CCM_8"},
    {0xC0AC, "TLS_ECDHE_ECDSA_WITH_AES_128_CCM"},
    {0xC0AD, "TLS_ECDHE_ECDSA_WITH_AES_256_CCM"},
    {0xC0AE, "TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8"},
    {0xC0AF, "TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8"},
    {0xCCA8, "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCA9, "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCAA, "TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCAB, "TLS_PSK_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCAC, "TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCAD, "TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"},
    {0xCCAE, "TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"},
    {0xFEFE, "SSL_RSA_FIPS_WITH_DES_CBC_SHA"},
    {0xFEFF, "SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"},
};

string kCertBase64 = 
"MIIFCDCCAvACCQDRDMKtkYdt3TANBgkqhkiG9w0BAQsFADBGMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpSmluZzESMBAGA1UEBwwJRG9uZ2NoZW5nMREwDwYDVQQDDAhqb2huLmNvbTAeFw0xNjA3MDgxMjQwMjZaFw0yNjA3MDYxMjQwMjZaMEYxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlKaW5nMRIwEAYDVQQHDAlEb25nY2hlbmcxETAPBgNVBAMMCGpvaG4uY29tMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAr2DUqCO3aubFvut3EsshCtxoPyWsIA06/of5Metdin7BeKqJvufGv9uv7p3HaFnETLX9BL+J7VsORK2QmFU5bw6SsGSuqxjNaiCDeNHYeGvpLFSl/zasH97G+hPTYLlxwdnAM7xIoeePUwFzkJlxSLz+mfvkTcnxhUcEepD3N6xoaM++D8YwTRyd3XrBH/CeFY2T4Kg+gCUfo2xFVPDY21yvDA1nya/3UKEGf+Nt3LoGxwuxl0nW7cXxcQMAjdTk9Krjfy21HQFIwonAYtmxJ6sOKyWRFc+TIKByq3R3S1KTw9CG9+3bCptgeM88nKTgm+zjE4wJQYTwnLtq8tjl4cYkUP+o5yUhuNWO6UabLwEm3QExS5fYANk0Rh86FBoE1Kvfaa4CTYtD7OXrMbJgHGvxEOTTwz2ZRLoSGqM9vwFNxUzsjqhM5vMtmuKRVXOCYeaomc2H9cq7a1D93xS3XNh+YvQ+ZMZcVF4ATcle/2Gew12AlHYGXyB9/Cqth+7ZDR5GSvWj4icS3t4xQjQUHQP5wZ5poLFRfXhygXz+gKLw9NHvLqd2O2PSI9dvLgZlJvxGvqa0CKLbYGH483lwuO49kQeGsbH2+BjMtgfiMemr7KJRcRh5iqa67ihHSL/QF+Epk3rpKB9sNghg+QQ3P4tR0BQBUAjX1NJMq9JJIm8CAwEAATANBgkqhkiG9w0BAQsFAAOCAgEAKBbiCPPxPH8Y8lHpb5ZD773P/61qAMfGsEICxm2zom8N3PWMNYme1qn7UdanZ4HiJwm6C/Sh6Wos3dxK9AZDQqJDhOaF4Q4uXpOb/wmPVq07MSFdeWNrKwgbR4sJ4FfNXYHfkAFW950yU9VdrjP3Oy2kLpkFsJfFXx3+RIuEKrcYq5qITOSFTroJxE++VfDFlvPKr8a9scqkK2rbQIGsPGqEXZyUsj/DsTeVqUkN/WPrZlWk0M0Hese+KeA4QQtFHt+EUtPhH1IzR7dQuSceV1WcrKvSKy+HPwELXxgagGjy/JyKin6ghIqoa6W2WHlybvH/6uoiAcdii7yVmvXsa7I6XHksEqHDPvTLKweBHEX4TwjGjyemnH4VM79CByCNGXH+65JKpAHq+EXg/TqBlXNqOwPlX9Gl3YIgHB/E5HEJeorybgzI4u8ViPldJmlIS6NQ2FY0xQ6diSP8rOzhvDnGAEVbrAUCBZc5eVIqkSibhheKCp5O6exlND9cytq58lIF4xMzQ2ZKFZ9MKB60WymVMpJaPhKg7ZDC6YdhEowN/y783PSPA57Wr6nIuSFuDz9fK1YvU80svRWfvKz/2e65GHnKv9WPKQu4TJma/InJaMVo7g90QIRbUQkXP8gim1BceJ3LHmER6N9pEanW1LWMcZYpvNb5N5/0q+IG0WY=";

string kPrivateKeyBase64 = 
"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";

HttpsFlvProtocol::HttpsFlvProtocol(Epoller* epoller, Fd* socket)
    :
    MediaSubscriber(kHttpFlv),
    epoller_(epoller),
    socket_(socket),
    media_publisher_(NULL),
    pre_tag_size_(0)
{
    ssl_ctx_ = SSL_CTX_new(TLS_server_method());

    if (ssl_ctx_ == NULL)
    {
        cout << LMSG << "SSL_CTX_new err:" << endl;
    }
    else
    {
        ssl_ = SSL_new(ssl_ctx_);
        if (ssl_ == NULL)
        {
            cout << LMSG << "SSL_new err:" << endl;
        }
    }

    Base64::Decode(kCertBase64, server_cert_);
    Base64::Decode(kPrivateKeyBase64, server_priv_key_);

    cout << "server_cert_:" << server_cert_.size() << endl;
    cout << "server_priv_key_:" << server_priv_key_.size() << endl;
}

HttpsFlvProtocol::~HttpsFlvProtocol()
{
}

int HttpsFlvProtocol::Parse(IoBuffer& io_buffer)
{
    uint8_t* data = NULL;
    int len = io_buffer.Peek(data, 0, io_buffer.Size());

    cout << LMSG << "len:" << len << endl;
    cout << Util::Bin2Hex(data, len) << endl;

    BitBuffer bit_buffer(data, len);

    if (len < 5)
    {
        return kNoEnoughData;
    }

    uint8_t content_type = 0;
    bit_buffer.GetBytes(1, content_type);

    cout << LMSG << "content_type:" << (int)content_type << endl;

    uint8_t version_major = 0;
    bit_buffer.GetBytes(1, version_major);

    cout << LMSG << "version_major:" << (int)version_major << endl;

    uint8_t version_minor = 0;
    bit_buffer.GetBytes(1, version_minor);
    cout << LMSG << "version_minor:" << (int)version_minor << endl;

    uint16_t record_length = 0;
    bit_buffer.GetBytes(2, record_length);
    cout << LMSG << "record_length:" << record_length << endl;

    if (len < record_length + 5)
    {
        return kNoEnoughData;
    }

    io_buffer.Skip(5);
    io_buffer.Read(data, record_length);

    uint8_t msg_type = 0;
    bit_buffer.GetBytes(1, msg_type);
    cout << LMSG << "msg_type:" << (int)msg_type << endl;

    if (content_type == kHandshake)
    {
        uint32_t length = 0;
        bit_buffer.GetBytes(3, length);
        cout << LMSG << "length:" << length << endl;

        if (msg_type == kClientHello)
        {
            // client hello
            bit_buffer.GetBytes(1, version_major);
            cout << LMSG << "version_major:" << (int)version_major << endl;
            bit_buffer.GetBytes(1, version_minor);
            cout << LMSG << "version_minor:" << (int)version_minor << endl;


            uint32_t gmt_unix_time = 0;
            bit_buffer.GetBytes(4, gmt_unix_time);
            cout << LMSG << "gmt_unix_time:" << gmt_unix_time << endl;

            string random_bytes;
            bit_buffer.GetString(28, random_bytes);
            cout << LMSG << "random_bytes:" << Util::Bin2Hex(random_bytes) << endl;

            uint8_t session_id_length = 0;
            bit_buffer.GetBytes(1, session_id_length);

            cout << "session_id_length:" << (int)session_id_length << endl;
            if (session_id_length > 0)
            {
                string session_id;
                bit_buffer.GetString(session_id_length, session_id);
                cout << LMSG << "session_id:" << Util::Bin2Hex(session_id) << endl;
            }

            uint16_t cipher_suite_length = 0;
            bit_buffer.GetBytes(2, cipher_suite_length);
            cout << LMSG << "cipher_suite_length:" << cipher_suite_length << endl;

            for (uint16_t i = 0; i != cipher_suite_length / 2; ++i)
            {
                uint8_t cipher_suite[2];
                bit_buffer.GetBytes(1, cipher_suite[0]);
                bit_buffer.GetBytes(1, cipher_suite[1]);

                uint16_t index = cipher_suite[0] << 8 | cipher_suite[1];

                cout << LMSG << "cipher_suite:" << Util::Bin2Hex(cipher_suite, 2) << endl;
                if (kCiphersTable.count(index))
                {
                    cout << LMSG << "client support cipher:" << kCiphersTable[index] << endl;
                }
                else
                {
                    cout << LMSG << "client unsupport cipher" << endl;
                }
            }

            uint8_t compression_methods_length = 0;
            bit_buffer.GetBytes(1, compression_methods_length);
            cout << LMSG << "compression_methods_length:" << (int)compression_methods_length << endl;

            uint8_t compression_methods = 255;
            if (compression_methods_length > 0)
            {
                bit_buffer.GetBytes(1, compression_methods);
                cout << LMSG << "compression_methods:" << (int)compression_methods << endl;
            }

            uint16_t extension_list_length = 0;
            bit_buffer.GetBytes(2, extension_list_length);
            cout << LMSG << "extension_list_length:" << extension_list_length << endl;

            uint16_t i = 0;
            while (i < extension_list_length)
            {
                uint8_t extension_id[2];
                bit_buffer.GetBytes(1, extension_id[0]);
                bit_buffer.GetBytes(1, extension_id[1]);
                cout << LMSG << "extension_id:" << Util::Bin2Hex(extension_id, 2) << endl;

                i += 2;

                uint16_t extension_data_length = 0;
                bit_buffer.GetBytes(2, extension_data_length);
                cout << LMSG << "extension_data_length:" << extension_data_length << endl;

                i+= 2;

                string extension_data;
                bit_buffer.GetString(extension_data_length, extension_data);

                i += extension_data_length;
                cout << LMSG << "BytesLeft:" << bit_buffer.BytesLeft() << endl;
            }

            cout << LMSG << "i:" << i << ",extension_list_length:" << extension_list_length << endl;

            cout << LMSG << "BytesLeft:" << bit_buffer.BytesLeft() << endl;

            // response in server hello
            {
                BitStream bs_handshake;
                bs_handshake.WriteBytes(1, 3);
                bs_handshake.WriteBytes(1, 1);
                uint32_t now = Util::GetNow();
                bs_handshake.WriteBytes(4, now);

                uint8_t random[28];
                bs_handshake.WriteData(28, random);

                uint8_t session_id_length = 32;
                bs_handshake.WriteBytes(1, session_id_length);

                uint8_t session_id[32];
                bs_handshake.WriteData(32, session_id);

                uint16_t select_cipher = 0x0035;
                bs_handshake.WriteBytes(2, select_cipher);

                uint8_t compression_methods_length = 0;
                bs_handshake.WriteBytes(1, compression_methods_length);

                uint16_t extension_list_length = 0;
                bs_handshake.WriteBytes(2, extension_list_length);

                BitStream bs_handshake_head_body;
                bs_handshake_head_body.WriteBytes(1, kServerHello);
                bs_handshake_head_body.WriteBytes(3, bs_handshake.SizeInBytes());
                bs_handshake_head_body.WriteData(bs_handshake.SizeInBytes(), bs_handshake.GetData());

                BitStream bs_tls_handshake_head_body;
                bs_tls_handshake_head_body.WriteBytes(1, kHandshake);
                bs_tls_handshake_head_body.WriteBytes(1, 3);
                bs_tls_handshake_head_body.WriteBytes(1, 1);
                bs_tls_handshake_head_body.WriteBytes(2, (uint16_t)bs_handshake_head_body.SizeInBytes());
                bs_tls_handshake_head_body.WriteData(bs_handshake_head_body.SizeInBytes(), bs_handshake_head_body.GetData());

                cout << LMSG << "ServerHello:" << Util::Bin2Hex(bs_tls_handshake_head_body.GetData(), bs_tls_handshake_head_body.SizeInBytes()) << endl;

                GetTcpSocket()->Send(bs_tls_handshake_head_body.GetData(), bs_tls_handshake_head_body.SizeInBytes());

                // server certifaicate
                BitStream bs_cert;
                bs_cert.WriteBytes(3, (uint32_t)server_cert_.size() + 3);
                bs_cert.WriteBytes(3, (uint32_t)server_cert_.size());
                bs_cert.WriteData(server_cert_.size(), (uint8_t*)server_cert_.data());

                BitStream bs_cert_head_body;
                bs_cert_head_body.WriteBytes(1, kCertificate);
                bs_cert_head_body.WriteBytes(3, (uint32_t)bs_cert.SizeInBytes());
                bs_cert_head_body.WriteData(bs_cert.SizeInBytes(), bs_cert.GetData());

                BitStream bs_tls_server_cert_head_body;

                bs_tls_server_cert_head_body.WriteBytes(1, kHandshake);
                bs_tls_server_cert_head_body.WriteBytes(1, 3);
                bs_tls_server_cert_head_body.WriteBytes(1, 1);
                bs_tls_server_cert_head_body.WriteBytes(2, bs_cert_head_body.SizeInBytes());
                bs_tls_server_cert_head_body.WriteData(bs_cert_head_body.SizeInBytes(), bs_cert_head_body.GetData());

                cout << LMSG << "ServerCert:" << Util::Bin2Hex(bs_tls_server_cert_head_body.GetData(), bs_tls_server_cert_head_body.SizeInBytes()) << endl;

                GetTcpSocket()->Send(bs_tls_server_cert_head_body.GetData(), bs_tls_server_cert_head_body.SizeInBytes());

                BitStream bs_server_hello_done;
                bs_server_hello_done.WriteBytes(1, kHandshake);
                bs_server_hello_done.WriteBytes(1, 3);
                bs_server_hello_done.WriteBytes(1, 1);
                bs_server_hello_done.WriteBytes(2, 0x0004);
                bs_server_hello_done.WriteBytes(1, kServerHelloDone);
                bs_server_hello_done.WriteBytes(3, 0x00000000);

                cout << LMSG << "ServerHelloDone:" << Util::Bin2Hex(bs_server_hello_done.GetData(), bs_server_hello_done.SizeInBytes()) << endl;
                GetTcpSocket()->Send(bs_server_hello_done.GetData(), bs_server_hello_done.SizeInBytes());

                return kSuccess;
            }
        }
        else if (msg_type == kClientKeyExchange)
        {
            uint16_t public_key_encrypted_length = 0;
            bit_buffer.GetBytes(2, public_key_encrypted_length);
            cout << LMSG << "public_key_encrypted_length:" << public_key_encrypted_length << endl;

            string public_key_encrypted;
            bit_buffer.GetString(public_key_encrypted_length, public_key_encrypted);

            //int rsa_size = RSA_size(g_rsa);
            int rsa_size = 0;
            uint8_t* decrypt_buffer = (uint8_t*)malloc(rsa_size + 1);

            //int ret = RSA_private_decrypt(rsa_size, (const uint8_t*)public_key_encrypted.data(), decrypt_buffer, g_rsa, RSA_NO_PADDING);
            //
            int ret = 0;

            if (ret > 0)
            {
                cout << LMSG << "RSA_private_decrypt ret:" << ret << endl;
                cout << LMSG << "crypt:" << endl;
                cout << Util::Bin2Hex(public_key_encrypted) << endl;

                cout << LMSG << "decrypt:" << endl;
                cout << Util::Bin2Hex(decrypt_buffer, ret) << endl;

                string pre_master_key((char*)decrypt_buffer + ret - 48, 48);
                cout << LMSG << "pre_master_key:" << endl;
                cout << Util::Bin2Hex(pre_master_key) << endl;
            }

            cout << LMSG << "BytesLeft:" << bit_buffer.BytesLeft() << endl;

            return kSuccess;
        }
    }
    else if (content_type == kChangeCipherSpec)
    {
        cout << LMSG << endl;
        return kSuccess;
    }
    else if (content_type == kAlert)
    {
        cout << LMSG << endl;
        return kClose;
    }
    else if (content_type == kApplicationData)
    {
        cout << LMSG << endl;
        return kSuccess;
    }

    return kNoEnoughData;
}

int HttpsFlvProtocol::SendFlvHeader()
{
    IoBuffer flv_header;

    flv_header.Write("FLV");
    flv_header.WriteU8(1);
    flv_header.WriteU8(0x05);
    flv_header.WriteU32(9);

    uint8_t* data = NULL;
    int len = flv_header.Read(data, flv_header.Size());

    socket_->Send(data, len);

    return kSuccess;
}

int HttpsFlvProtocol::SendMetaData(const string& metadata)
{
    IoBuffer flv_tag;

    uint32_t data_size = metadata.size();

    flv_tag.WriteU32(pre_tag_size_);

    flv_tag.WriteU8(kMetaData);

    flv_tag.WriteU24(data_size);
    flv_tag.WriteU24(0);
    flv_tag.WriteU8(0);
    flv_tag.WriteU24(0);

    uint8_t* buf = NULL;
    int buf_len = flv_tag.Read(buf, flv_tag.Size());

    socket_->Send(buf, buf_len);
    socket_->Send((const uint8_t*)metadata.data(), metadata.size());

    pre_tag_size_ = data_size + 11;

    return kSuccess;
}

int HttpsFlvProtocol::SendMediaData(const Payload& payload)
{
    if (payload.IsAudio())
    {
        return SendAudio(payload);
    }
    else if (payload.IsVideo())
    {
        return SendVideo(payload);
    }

    return -1;
}

int HttpsFlvProtocol::SendVideo(const Payload& payload)
{
    IoBuffer flv_tag;

    uint32_t data_size = payload.GetAllLen() + 5/*5 bytes avc header*/;

    flv_tag.WriteU32(pre_tag_size_);

    flv_tag.WriteU8(kVideo);

    flv_tag.WriteU24(data_size);
    flv_tag.WriteU24((payload.GetDts32()) & 0x00FFFFFF);
    flv_tag.WriteU8((payload.GetDts32() >> 24) & 0xFF);
    flv_tag.WriteU24(0);

    if (payload.IsIFrame())
    {
        cout << LMSG << "I frame" << endl;
        flv_tag.WriteU8(0x17);
    }
    else
    {
        flv_tag.WriteU8(0x27);
    }

    flv_tag.WriteU8(0x01); // AVC nalu

    uint32_t compositio_time_offset = payload.GetPts32() - payload.GetDts32();

    flv_tag.WriteU24(compositio_time_offset);

    uint8_t* buf = NULL;
    int buf_len = flv_tag.Read(buf, flv_tag.Size());

    socket_->Send(buf, buf_len);
    socket_->Send(payload.GetAllData(), payload.GetAllLen());

    pre_tag_size_ = data_size + 11;

    return kSuccess;
}

int HttpsFlvProtocol::SendAudio(const Payload& payload)
{
    IoBuffer flv_tag;

    uint32_t data_size = payload.GetAllLen();

    flv_tag.WriteU32(pre_tag_size_);

    flv_tag.WriteU8(kAudio);

    flv_tag.WriteU24(data_size);
    flv_tag.WriteU24((payload.GetDts32()) & 0x00FFFFFF);
    flv_tag.WriteU8((payload.GetDts32() >> 24) & 0xFF);
    flv_tag.WriteU24(0);

    uint8_t* buf = NULL;
    int buf_len = flv_tag.Read(buf, flv_tag.Size());

    socket_->Send(buf, buf_len);
    socket_->Send(payload.GetAllData(), payload.GetAllLen());

    pre_tag_size_ = data_size + 11;

    return kSuccess;
}

int HttpsFlvProtocol::SendVideoHeader(const string& video_header)
{
    IoBuffer flv_tag;

    uint32_t data_size = video_header.size() + 5;

    flv_tag.WriteU32(pre_tag_size_);

    flv_tag.WriteU8(kVideo);

    flv_tag.WriteU24(data_size);
    flv_tag.WriteU24(0);
    flv_tag.WriteU8(0);
    flv_tag.WriteU24(0);

    flv_tag.WriteU8(0x17);
    flv_tag.WriteU8(0x00); // AVC header
    flv_tag.WriteU24(0x000000);

    uint8_t* buf = NULL;
    int buf_len = flv_tag.Read(buf, flv_tag.Size());

    socket_->Send(buf, buf_len);
    socket_->Send((const uint8_t*)video_header.data(), video_header.size());

    pre_tag_size_ = data_size + 11;

    return kSuccess;
}

int HttpsFlvProtocol::SendAudioHeader(const string& audio_header)
{
    IoBuffer flv_tag;

    uint32_t data_size = audio_header.size() + 2;

    flv_tag.WriteU32(pre_tag_size_);

    flv_tag.WriteU8(kAudio);

    flv_tag.WriteU24(data_size);
    flv_tag.WriteU24(0);
    flv_tag.WriteU8(0);
    flv_tag.WriteU24(0);

    flv_tag.WriteU8(0xAF);
    flv_tag.WriteU8(0x00);

    uint8_t* buf = NULL;
    int buf_len = flv_tag.Read(buf, flv_tag.Size());

    socket_->Send(buf, buf_len);
    socket_->Send((const uint8_t*)audio_header.data(), audio_header.size());

    pre_tag_size_ = data_size + 11;

    return kSuccess;
}

int HttpsFlvProtocol::OnStop()
{
    if (media_publisher_ != NULL)
    {
        media_publisher_->RemoveSubscriber(this);
    }

    return kSuccess;
}

int HttpsFlvProtocol::EveryNSecond(const uint64_t& now_in_ms, const uint32_t& interval, const uint64_t& count)
{
    UNUSED(interval);
    UNUSED(count);

    if (expired_time_ms_ != 0)
    {
        if (now_in_ms > expired_time_ms_)
        {
            cout << LMSG << "expired, can't find media source, app_:" << app_ << ",stream_:" << stream_ << endl;

            OnPendingArrive();
        }
    }    

    return kSuccess;
}

int HttpsFlvProtocol::OnPendingArrive()
{
    cout << LMSG << "pending done" << endl;

    if (! app_.empty() && ! stream_.empty())
    {
        media_publisher_ = g_local_stream_center.GetMediaPublisherByAppStream(app_, stream_);

        cout << LMSG << endl;

        if (media_publisher_ != NULL) // 从MediaCenter查到了publish node
        {
            cout << LMSG << endl;
            if (type_ == "flv")
            {
                cout << LMSG << endl;

	            string http_response = "HTTP/1.1 200 OK\r\n"
                                       "Server: trs\r\n"
                                       "Content-Type: flv-application/octet-stream\r\n"
                                       "Connection: keep-alive\r\n"
                                       "\r\n";

	            GetTcpSocket()->Send((const uint8_t*)http_response.data(), http_response.size());
                SendFlvHeader();
                media_publisher_->AddSubscriber(this);

                expired_time_ms_ = 0;
            }
        }
        else
        {
            cout << LMSG << "can't find media source, app_:" << app_ << ",stream_:" << stream_ << endl;

			ostringstream os; 

            os << "HTTP/1.1 404 Not Found\r\n"
               << "Server: trs\r\n"
               << "Connection: close\r\n"
               << "\r\n";

            GetTcpSocket()->Send((const uint8_t*)os.str().data(), os.str().size());
        }
    }

    return kSuccess;
}
